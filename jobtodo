//ctrl+f TODO
//TODO: zrobic zeby kazda postac dziedziczyla po obiekcie obj_Actor, czy cos w tym stylu; wtedy przeciwnicy  (obj_NameOfTheEnemy) beda dzidziczyc w nastepujacy sposob:  obj_NameOfTheEnemy:obj_Enemy:obj_Actor
//TODO: przerobic ds_list_find_value na [#,list] czy jakos tak

par_Actor //parent po ktorym beda dziedziczyc wszystkie postaci, potwory, npc itp.
{
	CREATE()
	{
		state = STATE_NONE;
		dead = false;
	}	
}
par_NPC : par_Actor //parent po ktorym beda dziedziczyc wszystkie NPCe
{
	CREATE()
	{
		event_inherited();
		var dialogs = ds_map_create(); // lista (mapa) z dialogami
	}
}

//pulling leaver
if (place_meeting(x,y,obj_LeaverElevator) && place_meeting_solid(x,y+1) && !place_meeting(x,y+1,obj_Elevator))
{
	//call elevator
}

obj_Elevator : obj_Solid
{
	CREATE()
	{
		//binding the waypoints to the elevator
		scr_ElevatorBindWaypoints();
	}
	
	STEP()
	{
		if (state == ELEVATOR_MOVE)
		{
			if (waypoint!=noone)
			{
				var smoothSpd = distance_to_point(waypoint.x,waypoint.y) / smooth;
				smoothSpd = clamp(smoothSpd,-spd,spd);
				y += lengthdir_y(smoothSpd,dir);//sprawdzic czy dziala w przeciwnym razie speed = smoothSpd; direction = dir;
				
			}
			else //nie ma waypointa
			{
				debug_log("Winda nie ma waypointa",DEBUG_ERROR);
				state == ELEVATOR_STOP;
			}
			
			if (place_meeting(x,y-spd,obj_Hero))
			{
				var hero = obj_Hero;
				hero.y = y - offsetY; //sprawdz czy bedzie mogl podskoczyc
				//TODO: pokombinowac co zrobic zeby nie wtopil sie w sufit/róg
			}
		}
	}	
}
//wedlug Pomysłu wywływać to powinien obj_Binder, wiec nazwa zmieni sie na scr_BinderBindElevatorToWaypoints() i zrobione przy pomocy with (obj_Elevator)...
scr_ElevatorBindWaypoints()
{
	//under elevator
	for(var i = y; i < room_height; i+=16)
	{
		var waypoint = instance_place(x,i,obj_WaypointElevator);
		//if there is a waypoint and is not bound
		if (waypoint != noone && waypoint.bind == noone)		
			waypoint.bind = id;//(this)?
	}
	//above elevator
	for(var i = y; i>0; i+=16)
	{
		var waypoint = instance_place(x,i,obj_WaypointElevator);
		if (waypoint != noone && waypoint.bind == noone)
			waypoint.bind = id;//this?
	}
}

scr_ElevatorFindNextWapoint()
{	
	//under elevator
	if (dir == ELEVATOR_DOWN)
		for(var i = y; i < room_height; i+=16)
		{
			var waypoint = instance_place(x,i,obj_WaypointElevator);
			//if there is a waypoint
			if (waypoint != noone)
			{
				this.waypoint = waypoint; //sprawdzic czy nie bedzie sie pieprzyc, w przeciwnym wpadku zmienic w elevatorze zmienna waypoint na nextWaypoint i te linijke na: nextWaypoint = waypoint;
				exit;
			}
		}
		//above elevator
	else if (dir == ELEVATOR_UP)
		for(var i = y; i < room_height; i+=16)
		{
			var waypoint = instance_place(x,i,obj_WaypointElevator);
			if (waypoint != noone)
			{
				this.waypoint = waypoint; //sprawdzic czy nie bedzie sie pieprzyc...
				exit;
			}
		}
	debug_log("nie znaleziono zadnego waypointu",DEBUG_WARN);
}

par_Leaver
{
	CREATE()
	{
		turnOn = false;			//czy pociagnieta
		turned = true;			//czy jest juz na swoim miejscu (przeciagnieta do konca)
	}
	STEP()
	{
	//TODO:
		if (!turned)		
			if (turnOn)
			{
				//animacja "wlaczenia dzwigni"
			}			
			else
			{
				//animacja przeciwna
			}
	}
}
scr_LeaverTurn()
{
	if (turned)
	{
		turnOn = !turnOn;
		turned = false;
	}
}
obj_LeaverElevator : par_Leaver
{
	CREATE()
	{
		event_inherited();
	}
	STEP()
	{
		event_inherited();		
	}
}
obj_LeaverDoor : par_Leaver
{
	CREATE()
	{
		event_inherited(); //turnOn, turned
		door = noone; //id drzwi ktore sa otwieralne
		//TODO: wymyslic sposob na przypisywanie ktore drzwi maja byc otwierane przez dzwignie. Omijac rozwiazanie z dodatkowymi obiektami i creation_code
	}
	STEP()
	{
		event_inherited();
		if (door!=noone && turned)
			door.opened = turnOn;
	}
}

//TODO: wypróbować poniższy pomysł
//Pomysł: stworzyć obj_Binder ktory bedzie łączył ze sobą referencje obiektów, np. obj_LeaverDoor z jakimś obj_Door

obj_Binder
{
	CRAETE()
	{
			bound = false; 								//czy wszystko jest juz polaczone
			list = scr_BinderGetBindingsList(); 	//lista polaczen
	}
	STEP()
	{
			if (ds_list_size(list))
			{
				for(var i = 0; i<ds_list_size(list);i++)
				{
					var binding = ds_list_find_value(list,i);
					scr_BinderBound(binding);
				}
				bound = true;
			}
			
			if (bound)
				scr_BinderDispose();	//czyszczenie pamieci z wszystkich list i map po zakonczeniu łączenia;
	}
}

scr_BinderBound(binding)
{
	var type = ds_map_find_value(binding,"type");
	switch(type)
	{
		case BIND_ELEVATOR_TO_WAYPOINT: scr_BinderDoorToLeaver(binding); break;
		case BIND_ELEVATOR_TO_WAYPOINT: scr_BinderBindElevatorToWaypoints(binding); break;
		default: debug_log("Nie zaimplementowano binda dla typu: " + type,DEBUG_ERROR);
	}
}

scr_BinderDoorToLeaver(binding)
{
	var leaver = ds_map_find_value(binding,"leaver");
	var door = ds_map_find_value(binding,"door");
	if (instance_exists(leaver) && instance_exists(door))
	{
		leaver.door = door;
		debug_log("Przypisano " + leaver.id + " do "+ door.id,DEBUG_SUCCESS);
	}
	else
	{
		debug_log("Nie udalo sie przypisac dzwigni do drzwi");
	}
}


//TODO: obj_HeroStats (albo jakos tak), ktory bedzie przechowywał informacje o satystykach bohatera z pokoju do pokoju
obj_HeroStats
{
	Persistent = true;
	CREATE()
	{
	//scr_HeroStatsVariablesInit():
		Health = 0;
		MaxHealth =0;
	}
}


obj_Diagonal : obj_Solid
{
	CREATE()
	{
		event_inherited(); //isSolid;
	}
}
place_meeting_diagonal(x,y)
{
///place_meeting_diagonal(x,y)
var xx = argument0;
var yy = argument1;

	if (place_meeting(xx,yy,obj_Diagonal) && isSolid)
		return true;
		
	return false;
}
//wbiegaie po pochylym
if (place_meeting_diagonal(x+hspd,y)
{
	for (var i=0; i<8; i++)
	{
		if (!place_meeting_diagonal(x+hspd,y+i))
		{
			y+=i;
			break;
		}
	}
	hspd = 0;
}//zbieganie po pochylym
else if(place_meeting_diagonal(x+hspd,y+8))
{
	for (var i = 0; i<8;i++)
	{
		if !(place_meeting_diagonal(x+hspd,y+8-i)
		{
			y+=8-i;
			break;
		}
	}
}

//spadanie
if (vspd == _maxFallSpeed && !deathFall)
{
	if (deathFallCounter>=deathFallCounterCount)
	{
			debug_log("Przy upadku bedzie dead",DEBUG_INFO);
			deathFall = true;
	}
	else
		deathFallCounter++;
}
else
	deathFallCounter = 0;

//upadek
if (place_meeting_solid(x,y+vspd) && deathFall)
{
	scr_HeroDeath();	//smierc
	deathFall = false;	//juz nie spada
}

//skrypt umierania
scr_HeroDeath()
{
	if (!obj_DebugController.GodMode)
		dead = true;
	debug_log("DEATH",DEBUG_ERROR);
}


//TODO: jak juz bedzie drzewko talenow, to trzeba bedzie w debugerContollerze zrobic odpowiedni sposob na wlaczanie i wylaczanie umiejetnosci

///TODO: zaimplementowac te dwie funkcje o ktorych jest mowa w jednym z DoZrobienia w scr_HeroStateMove
//scr_keyboard_check_sides()
{
	if (keyboard_check(KEY_RIGHT) && !keyboard_check(KEY_LEFT))
	{
	 side = 1;
	 return true;
	}
	else if (keyboard_check(KEY_LEFT) && !keyboard_check(KEY_RIGHT))
	{
		side = -1;
		return true;
	}

	return false;
}

//scr_keyboard_check_pressed_sides()
{
	if (keyboard_check_pressed(KEY_RIGHT) && !keyboard_check(KEY_LEFT))
	{
	 side = 1;
	 return true;
	}
	else if (keyboard_check_pressed(KEY_LEFT) && !keyboard_check(KEY_RIGHT))
	{
		side = -1;
		return true;
	}

	return false;
}
